
/*
node-webpay
@yuichirowada
MIT License

* initialize
var webpay = require('node-webpay')(defaults);

* usage
webpay(command, params, callback);
webpay(params, callback); // with command prop in params
*/

'use strict';

var WebPay = module.exports = function(defaults) {

	// node-webpay error objects (code, message, param)
	var e_no_command_supplied = genErr('no_command_supplied', 'command must be supplied.');
	var e_params_not_object = genErr('params_not_object', 'params must be object.');
	var e_command_not_exist = genErr('command_not_exist', 'command does not exist.')


	// settings object contains HTTP-related parameters
	var settings = {
		auth: '',
		lang: 'en'
	}

	// if defaults is not an object, assume it be auth string
	if (!isObject(defaults)) {
		settings.auth = defaults;
		defaults = {};
	} else {
		['auth', 'lang'].forEach(function(e){
			if (defaults.hasOwnProperty(e)) {
				if (typeof defaults[e] === 'string') settings[e] = defaults[e];
				delete defaults[e]; // delete the property anyway
			}
		});
	}

	if (typeof settings.auth !== 'string') { throw('node-webpay: auth must be supplied and must be string'); }

	// default host: 'api.webpay.jp'
	// default apiver: 'v1'
	settings.host = defaults.host || 'api.webpay.jp';
	settings.apiver = defaults.apiver ? '/' + defaults.apiver + '/' : '/v1/';

	Object.freeze(settings);
	Object.freeze(defaults);


	/* Command object generator function */
	var commands = (function(settings) {

		var https = require('https');

		/* charge: 売上計上 */
		function charge(params, cb) {
			return r({ method: 'post', path: 'charges' }, params, cb);
		}

		/* authorize: 仮売上計上 */
		function authorize(params, cb) {
			params.capture = 'false';
			return charge(params, cb);
		}

		/* refund and capture: 払い戻し、仮売上の本売上化 */
		function chargeOps(command) {
			return function(params, cb) {

				var options = {
					method: 'post',
					path: 'charges/' + params.id + '/' + command
				};

				return r(options, params, cb);
			}
		}

		/* create command generator */
		function createCommand(command){
			return function(params, cb) {
				return r({ method: 'post', path: command }, params, cb);
			}
		}

		/* get command generator */
		function getCommand(command){
			return function(params, cb) {
				var options = { path: command };

				// parameter has id, means the request will return single object
				if (params.id) {
					options.path += '/' + params.id;
					delete params.id;

				// if parameter doesn't have id, the request will return list
				// parameters must be attached to url as query string
				// but this doesn't apply if command is tokens
				} else if (command !== 'tokens') {

					var qs = [];
					Object.keys(params).forEach(function(key){
						// count, offset, created[xxx] will only be valid
						if (/^(count|offset|created\[[a-zA-Z]*\])/.test(key)) {
							qs.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
						}
					});

					if (qs.length > 0) { options.path += '?' + qs.join('&'); }
				}

				return r(options, cb);
			};
		}

		/* resumeRecursion: 定期課金再開 */
		function resumeRecursion(params, cb) {
			return r({ method: 'post', path: 'recursions/' + params.id + '/resume' }, params, cb);
		}

		/* updateCustomer: 顧客情報更新 */
		function updateCustomer(params, cb) {
			return r({ method: 'post', path: 'customers/' + params.id }, params, cb);
		}

		/* deleteCustomer and deleteRecursion: 削除 */
		function deleteCommand(command) {
			return function(params, cb) {
				return r({ method: 'delete', path: command + '/' + params.id }, cb);
			}
		}
		
		/* deleteActiveCard: 顧客カード情報削除 */
		function deleteActiveCard(params, cb) {
			return r({ method: 'delete', path: 'customers/' + params.id + '/active_card' }, params, cb);
		}

		/* deleteTestData: テストデータ削除 */
		function deleteTestData(params, cb){
			return r({ method: 'delete', path: 'account/data' }, cb);
		}

		/* internal method for command interface */
		function r(options, params, cb) {

			if (typeof params === 'function') {
				cb = params;
				params = {};
			}

			// fix request options
			options.hostname = settings.host;
			options.auth = settings.auth;
			options.path = settings.apiver + options.path;
			if (settings.lang !== 'en') { options.headers = { "accept-language": settings.lang }; }

			// set Accept-Language header for error message
			// but only when lang is not 'en'
			// if string, apply params.lang to lang, and delete the property anyway

			if (params.hasOwnProperty('lang')) {
				if (typeof params.lang === 'string') options.headers = { "accept-language": params.lang };
				delete params.lang;
			}

			// request and callback handlings
			var req = https.request(options, function(res) {
				var data = '';
				res.on('data', function(d) {
					data += d;
				}).on('end', function() {
					data = JSON.parse(data);
					if (typeof cb === 'function') cb(data);
				}).on('error', function(e) {
					if (typeof cb === 'function') cb(e);
				});
			});

			// construct post data
			if (options.method === 'post') {

				var postData = [];
				Object.keys(params).forEach(function(val, idx) {
					postData.push(encodeURIComponent(val) + '=' + encodeURIComponent(params[val]));
				});
				
				req.write(postData.join('&'));

			}

			req.end();
			return true;
		}

		var api = {
			charge: charge,
			auth: authorize,
			refund: chargeOps('refund'),
			capture: chargeOps('capture'),
			getCharge: getCommand('charges'), // single id or list

			createCustomer: createCommand('customers'),
			getCustomer: getCommand('customers'), // single id or list
			updateCustomer: updateCustomer,
			deleteCustomer: deleteCommand('customers'),
			deleteActiveCard: deleteActiveCard,

			createToken: createCommand('tokens'),
			getToken: getCommand('tokens'), // single id only

			createRecursion: createCommand('recursions'),
			getRecursion: getCommand('recursions'), // single id or list
			resumeRecursion: resumeRecursion,
			deleteRecursion: deleteCommand('recursions'),

			getEvent: getCommand('events'), // single id or list
			getAccount: getCommand('account'),
			deleteTestData: deleteTestData
		}

		return api;

	})(settings);


	/* Interface function */
	function webpay(command, params, cb) {

		// if command string is not supplied, assume command string is supplied in params.command
		if (typeof command !== 'string') {
			cb = params;
			params = command;

			// execute callback with WebPay-like error object instead of throwing error (0.3.0)
			if (!params.hasOwnProperty('command')) { cb(e_no_command_supplied()); return false; }
			command = params.command;
			if (!commands.hasOwnProperty(command)) { cb(e_command_not_exist(command)); return false; }
		}

		// if params is not object, execute callback with WebPay-like error object instead of throwing error (0.3.0)
		if (!isObject(params)) { cb(e_params_not_object()); return false; }

		// delete command property from params if exists
		if (params.hasOwnProperty('command')) { delete params.command; }

		// copy defaults properties into params
		// starting 0.3.0, defaults will override supplied params
		Object.keys(defaults).forEach(function(prop) {
			params[prop] = defaults[prop];
		});

		// parse object properties into flat properties
		// should apply to card and created objects
		Object.keys(params).forEach(function(prop) {
			if(isObject(params[prop])) {
				Object.keys(params[prop]).forEach(function(cprop) {
					params[prop+'['+cprop+']'] = params[prop][cprop];
				});
				delete params[prop];
			}
		});

		// command execution
		return commands[command](params, cb);

	}

	// module returns webpay interface function
	return webpay;

	// utility functions

	function isObject(obj) {
		return Object.prototype.toString.call(obj) === '[object Object]';
	}

	// WebPay-like error object generation
	function genErr(code, message) {
		if(typeof code !== 'string' || typeof message !== 'string') throw('node-webpay: genErr not initialized properly');
		return function(param){
			return {
				error: {
					type: 'node-webpay',
					code: code,
					message: message,
					param: param
				}
			}
		};
	}

};
